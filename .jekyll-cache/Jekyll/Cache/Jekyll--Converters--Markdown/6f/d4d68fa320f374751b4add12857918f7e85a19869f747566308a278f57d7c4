I"›<p>S3 is rather cheap and you might wander why bother, but there are multiple good reasons to use a local substitute during development. Among them:</p>

<ul>
  <li>working offline, e.g. on a plane</li>
  <li>marginally lower latency</li>
  <li>no risk of bucket name collisions, especially when you create them like crazy during tests</li>
  <li>no fuss with credentials</li>
  <li>tear it apart all you want</li>
  <li>check those pesky edge cases with connectivity errors</li>
</ul>

<p>For context, I‚Äôll mention upfront that this solution was tested on a PHP project written in Laravel, but should be equally applicable for any other technology.</p>

<h2 id="whats-available">What‚Äôs available</h2>

<p>Some solutions we‚Äôve tried out:</p>

<ul>
  <li><a href="https://min.io/">MinIO</a> ‚Äì a storage service in its own right, but maintaining a (mostly) S3-compatible API. Has its own set of tools and a GUI.</li>
  <li><a href="https://github.com/adobe/S3Mock">S3Mock from Adobe</a> ‚Äì focused on API compatibility, no frills. Written in Java.</li>
  <li><a href="https://github.com/jubos/fake-s3">Fake S3</a> ‚Äì similar to S3Mock (it‚Äôs even referenced in their GH page). Written in Ruby.</li>
</ul>

<h2 id="implementation">Implementation</h2>

<p>Out of those, we‚Äôve ended up using MinIO. It was mostly because of convenience as we were already using <a href="https://laravel.com/docs/master/homestead">Homestead</a> Vagrant box for development and it came as an installation option with it. It was also important for me to have some tools to inspect all buckets during manual tests and since none of those solutions worked correctly with AWS Cli tool for me, MinIO came through with its GUI and Cli tool (somewhat confusingly called <code class="highlighter-rouge">mc</code> aka <em>Not Midnight Commander</em>).</p>

<p>Not to say that, e.g. S3Mock, was difficult to set up. My collegue came up with the painless solution of using the <a href="https://www.vagrantup.com/docs/provisioning/docker.html">docker provisioner</a> in Vagrant. A snippet you can use in your <code class="highlighter-rouge">Vagrantfile</code> (in our case it meant modifying Homestead‚Äôs Vagrantfile):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ...
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
    config.vm.provision "docker" do |d|
        d.pull_images "adobe/s3mock"
        d.run "adobe/s3mock",
          args: "-p 9090:9090 -p 9191:9191"
    end
    # ...
</code></pre></div></div>

<p>However, to get MinIO in Homestead, all you have to do is enable it in the <code class="highlighter-rouge">Homestead.yaml</code> file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>features:
	- minio: true
</code></pre></div></div>

<p>In versions 5.7+ you can also pre-define buckets and their policies that should be provisioned for you in a separate, <code class="highlighter-rouge">buckets</code> section. Beware that you can add that configurations in previous versions without triggering any errors, but it will just be ignored.</p>

<p>Credentials will also need to be updated. MinIO that bundles with Homestead uses a dummy login and password, but unlike the S3Mock (at least by default), it actually checks them, so update your configuration accordingly.</p>

<p>Last thing to do is to do is to update local configuration to use thus provisioned service. Depending on whether you use Flysystem, Laravel‚Äôs Filesystem or AWS SDK directly, this step might look differently for you. The important part is that with a local service you‚Äôll need to use something called ‚Äúpath style endpoint‚Äù for AWS API. Laravel‚Äôs documentation gives an <a href="https://laravel.com/docs/5.7/homestead#configuring-minio">example for the Filesystem configuration</a>. The crux of the matter is that because the service is local, buckets url‚Äôs will no longer be conveniently generated for you by AWS. The way around that, bar some local DNS configuration, is to use a static domain and put the bucket name in the path of the url.</p>

<p>Apart from that, it‚Äôs business as usual. All the logic written for the actual S3 should work with your local substitute.</p>

<h2 id="downsides">Downsides</h2>

<p>Not everything is rosy though. All of the services strive to keep their API S3 compatible, but your mileage will vary depending on how many features of S3 you actually rely on.</p>

<p>Examples I‚Äôve encountered include:</p>

<ul>
  <li>needing to change from <code class="highlighter-rouge">public</code> policy to <code class="highlighter-rouge">download</code> to achieve a result similar to AWS‚Äôs own ‚Äúpublic objects‚Äù. Somewhat frustratingly, I could not find a clear explanation of policy differences in MinIO docs. I still feel like I was missing some key piece of information to set it up better, but it didn‚Äôt help that at the time there was no one centralised information source on available polices. Therefore I‚Äôd suggest to check if features like hosted websites, complex ACL setups, CORS policies or object life-cycles will be sufficiently supported for your needs.</li>
  <li>some of the aws cli commands just would not work. Most frustratingly <code class="highlighter-rouge">s3 ls</code> with an endpoint url defined would just throw an error. Same story with third party browsers like Dragon Disk (tried that and some others just for due diligence, didn‚Äôt like any of them)</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>All the solutions performed well enough to warrant a recommendation (see the caveats above though). Using a local replacement for S3 makes development feel a bit safer and makes testing less stressful. If you‚Äôre considering it, just give it a try and see if it‚Äôs an (almost) drop-in replacement or not.</p>
:ET